<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF2PDF – Browser PDF Compressor</title>
  <!-- Client‑side only. Works on GitHub Pages. -->
  <!-- pdf-lib for writing/rebuilding PDFs -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <!-- pdf.js (stable v2 UMD build with global pdfjsLib) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <style>
    :root { --bg:#0f1115; --panel:#151923; --muted:#8b93a7; --text:#e6eaf2; --accent:#6aa7ff; --ok:#45d48a; --warn:#ffcc66; --err:#ff6b6b; --border:#232a3a; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{max-width:980px;margin:40px auto;padding:0 16px}
    .card{background:linear-gradient(180deg,#121623 0%,#0f1320 100%);border:1px solid var(--border);border-radius:16px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h1{font-size:26px;margin:0 0 4px;letter-spacing:.2px;background:linear-gradient(90deg,#dfe7ff,#82b1ff); -webkit-background-clip:text;background-clip:text;color:transparent}
    .sub{color:var(--muted);margin-bottom:18px}
    .row{display:grid;gap:12px;grid-template-columns:1fr 1fr}
    @media (max-width:800px){.row{grid-template-columns:1fr}}
    .pane{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
    .drop{border:2px dashed #334166;border-radius:14px;padding:18px;text-align:center;transition:.15s border-color,.15s background;cursor:pointer;user-select:none}
    .drop.dragover{border-color:var(--accent);background:rgba(106,167,255,.08)}
    .controls label{display:block;margin:6px 0 4px;color:var(--muted)}
    .controls input[type="number"],.controls select{width:100%;background:#0c0f17;color:var(--text);border:1px solid var(--border);border-radius:8px;padding:8px}
    .controls .inline{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{background:#203055;color:#e8efff;border:1px solid #304064;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600;transition:.15s transform,.15s background}
    button:hover{background:#29406e;transform:translateY(-1px)}
    button.primary{background:#2b63ff;border-color:#2b63ff}
    button.primary:hover{background:#2956d1}
    button.ghost{background:transparent;border-color:var(--border);color:var(--muted)}
    .progress{height:10px;background:#0c0f17;border:1px solid var(--border);border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,#6aa7ff,#45d48a);transition:width .2s}
    .log{height:320px;overflow:auto;background:#0c0f17;border:1px solid var(--border);border-radius:10px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;white-space:pre-wrap}
    .kv{display:grid;grid-template-columns:160px 1fr;gap:6px;margin:10px 0 0}
    .kv div:nth-child(odd){color:var(--muted)}
    a.download{color:#a7c4ff;text-decoration:none;border-bottom:1px dashed #2b63ff}
    .footer{margin-top:18px;color:var(--muted);font-size:12px}
    .hint{font-size:12px;color:var(--muted);opacity:.9;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>PDF2PDF</h1>
      <div class="sub">Compress PDFs in your browser. No uploads. Drag & drop or use the picker. Dark mode by default ✨</div>
      <div class="row">
        <div class="pane">
          <div id="drop" class="drop">
            <div style="font-size:15px;margin-bottom:6px">Drop PDF here or click to select</div>
            <div class="hint">Max tested ~200 MB (depends on RAM)</div>
            <input id="fileInput" type="file" accept="application/pdf" style="display:none" />
          </div>
          <div class="controls" style="margin-top:12px">
            <label for="mode">Mode</label>
            <select id="mode">
              <option value="mixed" selected>Mixed (searchable: raster + hidden text)</option>
              <option value="rasterize">Rasterize (maximum size reduction)</option>
              <option value="aggressive">Aggressive (tiny file, grayscale)</option>
              <option value="optimize">Optimize (preserve text & vectors)</option>
            </select>
            <div id="rasterOpts" style="display:block;margin-top:8px">
              <div class="inline">
                <div>
                  <label for="dpi">DPI (render resolution)</label>
                  <input id="dpi" type="number" min="72" max="600" value="300" />
                </div>
                <div>
                  <label for="quality">JPEG quality</label>
                  <input id="quality" type="number" min="0.3" max="0.95" step="0.05" value="0.75" />
                </div>
              </div>
              <div style="margin-top:6px">
                <label><input id="debugText" type="checkbox" /> Show text overlay (debug)</label>
              </div>
            </div>
            <div style="margin-top:10px">
              <label>Options</label>
              <div>
                <label><input id="stripMeta" type="checkbox" checked /> Strip metadata/XMP where possible</label><br/>
                <label><input id="linearize" type="checkbox" /> Fast‑web‑view (linearize) <span class="hint">beta</span></label><br/>
                <label><input id="safeMode" type="checkbox" checked /> Safe mode (defensive parsing)</label>
              </div>
            </div>
            <div class="btns">
              <button id="start" class="primary">Start compression</button>
              <button id="cancel" class="ghost">Cancel</button>
              <button id="reset" class="ghost">Reset</button>
            </div>
          </div>
        </div>
        <div class="pane">
          <div class="kv">
            <div>Selected file</div><div id="fname">—</div>
            <div>Original size</div><div id="fsize">—</div>
            <div>Output size</div><div id="osize">—</div>
            <div>Reduction</div><div id="reduct">—</div>
          </div>
          <div style="margin:12px 0 8px">Progress</div>
          <div class="progress"><div id="bar" class="bar"></div></div>
          <div style="margin:10px 0 6px">Logs</div>
          <div id="log" class="log"></div>
          <div id="downloadSlot" style="margin-top:10px"></div>
          <div class="footer">All processing happens locally in your browser. Nothing is uploaded.</div>
        </div>
      </div>
    </div>
    <div class="hint">Tip: Put this file as <code>index.html</code> in a GitHub repo and enable Pages → it just works.</div>
  </div>
<script>
'use strict';
// ========= Helpers =========
const $ = (id) => document.getElementById(id);
const logEl = $("log");
let abortFlag = false, running = false, fileBytes = null, fileName = null;
function log(msg, type="info"){ const m = type==="ok"?"✅": type==="warn"?"⚠️": type==="err"?"❌":"•"; logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m} ${msg}\n`; logEl.scrollTop = logEl.scrollHeight; }
function setProgress(p){ $("bar").style.width = `${Math.max(0,Math.min(100,p))}%`; }
function fmtBytes(n){ if(n===0) return "0 B"; const k=1024,u=["B","KB","MB","GB"];const i=Math.floor(Math.log(n)/Math.log(k)); return `${(n/Math.pow(k,i)).toFixed(i?1:0)} ${u[i]}`; }
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

// Polyfill canvas.toBlob in Safari
if (!HTMLCanvasElement.prototype.toBlob) {
  HTMLCanvasElement.prototype.toBlob = function(callback, type, quality) {
    const dataURL = this.toDataURL(type, quality).split(',')[1];
    setTimeout(()=>callback(new Blob([Uint8Array.from(atob(dataURL), c=>c.charCodeAt(0))], {type: type||'image/png'})));
  };
}

// Prevent default browser drop behavior
window.addEventListener('dragover', e=>e.preventDefault());
window.addEventListener('drop', e=>e.preventDefault());

// pdf.js worker config (after library script tag)
(function ensurePdfJs(){
  const trySet = () => {
    if (typeof window.pdfjsLib !== 'undefined'){
      if (!pdfjsLib.GlobalWorkerOptions.workerSrc){
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
      }
      log(`pdf.js ready (v${pdfjsLib.version || '2.x'}).`,'ok');
    } else {
      setTimeout(trySet, 200);
    }
  };
  trySet();
})();

// ========= Uploader =========
const drop = $("drop"), fileInput = $("fileInput");
drop.addEventListener('click',()=> fileInput.click());
drop.addEventListener('dragenter',()=> drop.classList.add('dragover'));
drop.addEventListener('dragleave',()=> drop.classList.remove('dragover'));
drop.addEventListener('dragover',(e)=>{ e.preventDefault(); drop.classList.add('dragover'); });
drop.addEventListener('drop', async (e)=>{ e.preventDefault(); drop.classList.remove('dragover'); const f=e.dataTransfer.files?.[0]; if(f) await loadFile(f); });
fileInput.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(f) await loadFile(f); });

async function loadFile(f){
  if(!f || (!/pdf$/i.test(f.type) && !/\.pdf$/i.test(f.name))){ log('Please select a PDF.','warn'); return; }
  if(running){ log('Busy. Click Cancel/Reset first.','warn'); return; }
  fileName = f.name.replace(/\.pdf$/i, '') || 'document';
  $("fname").textContent = f.name; $("fsize").textContent = fmtBytes(f.size);
  $("osize").textContent = '—'; $("reduct").textContent = '—'; setProgress(0); $("downloadSlot").innerHTML='';
  fileBytes = new Uint8Array(await f.arrayBuffer());
  log(`Loaded "${f.name}" (${fmtBytes(f.size)})`);
}

// ========= UI toggles =========
$("mode").addEventListener('change',()=>{ $("rasterOpts").style.display = $("mode").value!=='optimize' ? 'block':'none'; });
$("cancel").addEventListener('click',()=>{ if(running){ abortFlag=true; log('Cancellation requested…','warn'); }});
$("reset").addEventListener('click', resetUI);
function resetUI(){ abortFlag=false; running=false; fileBytes=null; fileName=null; $("fname").textContent='—'; $("fsize").textContent='—'; $("osize").textContent='—'; $("reduct").textContent='—'; setProgress(0); $("downloadSlot").innerHTML=''; logEl.textContent=''; fileInput.value=''; log('Reset ready.'); }

// ========= Optimize (lossless-ish) =========
async function compressOptimize(bytes, opts){
  const { PDFDocument, PDFName } = PDFLib;
  log('Reading PDF (optimize)…');
  const loadOpts = opts.safeMode ? { ignoreEncryption:false, updateMetadata:false } : {};
  const doc = await PDFDocument.load(bytes, loadOpts);
  if(abortFlag) throw new Error('Cancelled');

  if (opts.stripMeta){
    try{
      doc.setTitle(''); doc.setAuthor(''); doc.setSubject(''); doc.setKeywords([]); doc.setProducer(''); doc.setCreator('');
      doc.setCreationDate(undefined); doc.setModificationDate(undefined);
      const rootRef = doc.context.trailerInfo.Root;
      if (rootRef) {
        const cat = doc.context.lookup(rootRef);
        const del = key => { if(cat && cat.dict && cat.dict.has(PDFName.of(key))) { cat.dict.delete(PDFName.of(key)); } };
        del('Metadata'); del('PageLabels'); del('Names'); del('Outlines'); del('Threads'); del('OCProperties'); del('PieceInfo'); del('StructTreeRoot');
      }
      for (const p of doc.getPages()){
        const pd = p.node.dict;
        ['Annots','AA','Metadata','Thumb'].forEach(k=>{ if(pd.has(PDFName.of(k))) pd.delete(PDFName.of(k)); });
      }
      log('Stripped metadata, names/outlines, page annotations, thumbs.','ok');
    } catch(e){ log('Metadata/structure strip: non‑fatal issue.','warn'); }
  }

  log('Rewriting with object streams & deflate…');
  const out = await doc.save({ useObjectStreams:true, addDefaultPage:false });
  return out;
}

// ========= Rasterize (max reduction) =========
async function compressRasterize(bytes, { dpi=300, quality=0.75 }){
  if (typeof pdfjsLib === 'undefined') throw new Error('pdf.js not loaded');
  const scaleDPI = clamp(dpi, 72, 600);
  const q = clamp(quality, .3, .95);
  log(`Rasterizing at ${scaleDPI} DPI, JPEG quality ${q}…`);

  pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsLib.GlobalWorkerOptions.workerSrc || 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

  const pdf = await pdfjsLib.getDocument({ data: bytes, useSystemFonts: true }).promise;
  const pageCount = pdf.numPages; log(`Pages: ${pageCount}`);
  const { PDFDocument } = PDFLib; const outDoc = await PDFDocument.create();
  const pxPerInch = 96; const baseScale = scaleDPI/pxPerInch;

  for (let i=1; i<=pageCount; i++){
    if (abortFlag) throw new Error('Cancelled');
    const page = await pdf.getPage(i);
    const viewport = page.getViewport({ scale: baseScale });
    const canvas = document.createElement('canvas');
    canvas.width = Math.max(1, Math.floor(viewport.width));
    canvas.height = Math.max(1, Math.floor(viewport.height));
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

    setProgress(Math.round(((i-1)/pageCount)*60)+5);
    log(`Rendering page ${i}/${pageCount}…`);
    await page.render({ canvasContext: ctx, viewport, intent: 'print' }).promise;

    setProgress(Math.round((i/pageCount)*70));
    const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', q));
    const imgBytes = new Uint8Array(await blob.arrayBuffer());

    const img = await outDoc.embedJpg(imgBytes);
    const outPage = outDoc.addPage([img.width, img.height]);
    outPage.drawImage(img, { x:0, y:0, width: img.width, height: img.height });
    log(`Page ${i} embedded (${fmtBytes(imgBytes.length)}).`, 'ok');

    canvas.width = 0; canvas.height = 0;
    setProgress(Math.round(70 + (i/pageCount)*20));
  }

  const out = await outDoc.save({ useObjectStreams:true, addDefaultPage:false });
  return out;
}

// ========= Mixed (searchable: raster + hidden text) =========
async function compressMixed(bytes, { dpi=300, quality=0.75, debugText=false }){
  if (typeof pdfjsLib === 'undefined') throw new Error('pdf.js not loaded');
  const scaleDPI = clamp(dpi, 72, 600);
  const q = clamp(quality, .3, .95);
  log(`Mixed mode: raster ${scaleDPI} DPI JPEG ${q} + hidden text overlay…`);

  pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsLib.GlobalWorkerOptions.workerSrc || 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

  const pdf = await pdfjsLib.getDocument({ data: bytes, useSystemFonts: true }).promise;
  const pageCount = pdf.numPages; log(`Pages: ${pageCount}`);

  const { PDFDocument, StandardFonts, rgb } = PDFLib;
  const outDoc = await PDFDocument.create();
  const helv = await outDoc.embedFont(StandardFonts.Helvetica);

  const pxPerInch = 96; const baseScale = scaleDPI/pxPerInch;

  for (let i=1; i<=pageCount; i++){
    if (abortFlag) throw new Error('Cancelled');
    const page = await pdf.getPage(i);
    const viewport = page.getViewport({ scale: baseScale });

    // Render page bitmap first
    const canvas = document.createElement('canvas');
    canvas.width = Math.max(1, Math.floor(viewport.width));
    canvas.height = Math.max(1, Math.floor(viewport.height));
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

    setProgress(Math.round(((i-1)/pageCount)*50)+5);
    await page.render({ canvasContext: ctx, viewport, intent: 'print' }).promise;

    const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', q));
    const imgBytes = new Uint8Array(await blob.arrayBuffer());
    const img = await outDoc.embedJpg(imgBytes);

    const outPage = outDoc.addPage([img.width, img.height]);
    outPage.drawImage(img, { x:0, y:0, width: img.width, height: img.height });

    // Extract text content and overlay invisible text
    const text = await page.getTextContent();
    let placed = 0;
    const items = text.items || [];

    for (const it of items){
      // Map PDF.js text matrix into viewport space
      const m = pdfjsLib.Util.transform(viewport.transform, it.transform);
      const x = m[4];
      const yTop = m[5];
      const fontSize = Math.max(0.1, Math.hypot(m[2], m[3]));
      const y = viewport.height - yTop - fontSize * 0.2; // baseline approx

      const chunks = (it.str || '').split(/(\s+)/).filter(Boolean);
      let cx = x;
      for (const chunk of chunks){
        if (!chunk) continue;
        outPage.drawText(chunk, {
          x: cx,
          y,
          size: fontSize,
          font: helv,
          color: debugText ? rgb(1, 0, 0) : rgb(0, 0, 0),
          opacity: debugText ? 0.7 : 0.01,
        });
        cx += helv.widthOfTextAtSize(chunk, fontSize);
      }
      placed++;
    }

    log(`Page ${i}: text items placed ${placed}.`, 'ok');

    canvas.width = 0; canvas.height = 0;
    setProgress(Math.round(50 + (i/pageCount)*45));
  }

  const out = await outDoc.save({ useObjectStreams:true, addDefaultPage:false });
  return out;
}

// ========= Aggressive (absolute minimum size) =========
async function compressAggressive(bytes) {
  if (typeof pdfjsLib === 'undefined') throw new Error('pdf.js not loaded');
  log('Aggressive mode: target ~1.0 MP/page, grayscale, JPEG q=0.5 …');
  pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsLib.GlobalWorkerOptions.workerSrc || 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

  const pdf = await pdfjsLib.getDocument({ data: bytes, useSystemFonts: true }).promise;
  const pageCount = pdf.numPages; log(`Pages: ${pageCount}`);
  const { PDFDocument } = PDFLib; const outDoc = await PDFDocument.create();

  const targetMP = 1.0; // megapixels per page

  for (let i=1; i<=pageCount; i++){
    if (abortFlag) throw new Error('Cancelled');
    const page = await pdf.getPage(i);

    // Get base size at scale=1
    const base = page.getViewport({ scale: 1 });
    const basePixels = base.width * base.height;
    let scale = Math.sqrt((targetMP * 1_000_000) / Math.max(1, basePixels));
    scale = Math.min(scale, 1); // never upscale
    // Also cap to ~120 DPI vs 96 CSS px/in (roughly 1.25x)
    const maxAggressiveScale = 120/96;
    scale = Math.min(scale, maxAggressiveScale);

    const viewport = page.getViewport({ scale });

    // Render to canvas
    const canvas = document.createElement('canvas');
    canvas.width = Math.max(1, Math.floor(viewport.width));
    canvas.height = Math.max(1, Math.floor(viewport.height));
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
    setProgress(Math.round(((i-1)/pageCount)*60)+5);
    await page.render({ canvasContext: ctx, viewport, intent: 'print' }).promise;

    // Convert to grayscale to shrink size further
    const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = imgData.data;
    for (let p=0; p<data.length; p+=4){
      const r=data[p], g=data[p+1], b=data[p+2];
      // Rec. 709 luma
      const y = 0.2126*r + 0.7152*g + 0.0722*b;
      data[p]=data[p+1]=data[p+2]=y;
    }
    ctx.putImageData(imgData,0,0);

    // JPEG at lower quality
    const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.5));
    const imgBytes = new Uint8Array(await blob.arrayBuffer());

    const img = await outDoc.embedJpg(imgBytes);
    const outPage = outDoc.addPage([img.width, img.height]);
    outPage.drawImage(img, { x:0, y:0, width: img.width, height: img.height });
    log(`Aggressive page ${i} embedded (${fmtBytes(imgBytes.length)}).`, 'ok');

    canvas.width = 0; canvas.height = 0;
    setProgress(Math.round(70 + (i/pageCount)*20));
  }

  const out = await outDoc.save({ useObjectStreams:true, addDefaultPage:false });
  return out;
}

// ========= Orchestration =========
$("start").addEventListener('click', async ()=>{
  if (!fileBytes){ log('Choose a PDF first.','warn'); return; }
  if (running){ log('Already running. Use Cancel/Reset.','warn'); return; }
  abortFlag=false; running=true; setProgress(3);

  const mode = $("mode").value;
  const opts = {
    stripMeta: $("stripMeta").checked,
    linearize: $("linearize").checked,
    safeMode: $("safeMode").checked,
    dpi: parseInt($("dpi").value,10)||300,
    quality: parseFloat($("quality").value)||0.75,
    debugText: $("debugText").checked
  };

  try{
    log(`Starting compression in "${mode}" mode…`);
    const t0 = performance.now();
    let out;
    if (mode==='optimize') out = await compressOptimize(fileBytes, opts);
    else if (mode==='mixed') out = await compressMixed(fileBytes, opts);
    else if (mode==='aggressive') out = await compressAggressive(fileBytes);
    else out = await compressRasterize(fileBytes, opts);

    if (opts.linearize) log('Note: true PDF linearization is complex and not fully implemented (UI option is advisory).','warn');

    const dt = (performance.now()-t0)/1000; setProgress(100);
    const orig = fileBytes.byteLength, now = out.byteLength;
    $("osize").textContent = fmtBytes(now); $("reduct").textContent = `${((1-now/orig)*100).toFixed(1)}%`;
    log(`Done in ${dt.toFixed(2)}s. Original ${fmtBytes(orig)} → Output ${fmtBytes(now)} (${((1-now/orig)*100).toFixed(1)}% smaller).`,'ok');

    const blob = new Blob([out], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download=`${fileName}_compressed.pdf`; a.textContent='Download compressed PDF'; a.className='download';
    $("downloadSlot").innerHTML=''; $("downloadSlot").appendChild(a);
  } catch(e){ console.error(e); log(`Error: ${e && e.message ? e.message : e}`,'err'); }
  finally { running=false; }
});
</script>
</body>
</html>
